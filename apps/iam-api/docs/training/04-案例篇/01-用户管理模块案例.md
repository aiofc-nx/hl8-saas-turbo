# 用户管理模块案例

## 学习目标

- 通过完整的用户管理模块开发案例，理解整个开发流程
- 学习如何设计聚合根、值对象、领域事件
- 学习如何编写 Use Case（Command Handler、Query Handler）
- 学习如何实现端口适配器

## 1. 业务需求分析

### 1.1 业务需求

开发一个用户管理模块，需要支持：

- 创建用户（用户名、密码、域、昵称等）
- 更新用户信息（昵称、头像、邮箱、手机号等）
- 删除用户
- 查询用户（根据 ID、用户名、分页查询等）
- 用户登录（密码验证）

### 1.2 业务规则

- 用户名在域内必须唯一
- 密码必须加密存储
- 用户有状态（启用/禁用），只有启用状态的用户才能登录
- 用户创建后需要发布事件，用于初始化权限等后续操作

## 2. 领域模型设计

### 2.1 聚合根：User

```typescript
// lib/bounded-contexts/iam/authentication/domain/user.ts
export class User extends AggregateRoot implements IUser {
  readonly id: string;
  readonly username: string;
  readonly password: Password; // 值对象
  readonly domain: string;
  readonly status: Status;
  readonly nickName: string;
  readonly avatar: string | null;
  readonly email: string | null;
  readonly phoneNumber: string | null;
  createdAt: Date;
  createdBy: string;

  // 领域方法：验证密码
  async verifyPassword(password: string): Promise<boolean> {
    return this.password.compare(password);
  }

  // 领域方法：用户登录
  async loginUser(
    password: string,
  ): Promise<{ success: boolean; message: string }> {
    if (this.status !== Status.ENABLED) {
      return {
        success: false,
        message: `User is ${this.status.toLowerCase()}.`,
      };
    }
    const isPasswordValid = await this.verifyPassword(password);
    if (!isPasswordValid) {
      return { success: false, message: 'Invalid credentials.' };
    }
    return { success: true, message: 'Login successful' };
  }

  // 领域方法：发布创建事件
  async created() {
    this.apply(new UserCreatedEvent(this.id, this.username, this.domain));
  }

  // 领域方法：发布删除事件
  async deleted() {
    this.apply(new UserDeletedEvent(this.id, this.username, this.domain));
  }
}
```

### 2.2 值对象：Password

```typescript
// lib/bounded-contexts/iam/authentication/domain/password.value-object.ts
export class Password {
  private constructor(private readonly value: string) {}

  // 工厂方法：从明文密码创建
  static async hash(password: string): Promise<Password> {
    const salt = await bcrypt.genSalt();
    const hashedPassword = await bcrypt.hash(password, salt);
    return new Password(hashedPassword);
  }

  // 工厂方法：从已哈希的密码创建
  static fromHashed(hashed: string): Password {
    return new Password(hashed);
  }

  // 比较密码
  async compare(plainPassword: string): Promise<boolean> {
    return await bcrypt.compare(plainPassword, this.value);
  }

  // 获取密码哈希值
  getValue(): string {
    return this.value;
  }
}
```

### 2.3 领域事件

```typescript
// lib/bounded-contexts/iam/authentication/domain/events/user-created.event.ts
export class UserCreatedEvent implements IEvent {
  constructor(
    public readonly userId: string,
    public readonly username: string,
    public readonly domain: string,
  ) {}
}

// lib/bounded-contexts/iam/authentication/domain/events/user-deleted.event.ts
export class UserDeletedEvent implements IEvent {
  constructor(
    public readonly userId: string,
    public readonly username: string,
    public readonly domain: string,
  ) {}
}
```

## 3. Use Case 实现

### 3.1 写操作 Use Case：创建用户

```typescript
// lib/bounded-contexts/iam/authentication/application/command-handlers/user-create.command.handler.ts
@CommandHandler(UserCreateCommand)
export class UserCreateHandler
  implements ICommandHandler<UserCreateCommand, void>
{
  constructor(private readonly publisher: EventPublisher) {}

  @Inject(UserWriteRepoPortToken)
  private readonly userWriteRepository: UserWriteRepoPort;

  @Inject(UserReadRepoPortToken)
  private readonly userReadRepoPort: UserReadRepoPort;

  async execute(command: UserCreateCommand) {
    // Use Case 步骤 1: 验证用户名唯一性
    const existingUser = await this.userReadRepoPort.getUserByUsername(
      command.username,
    );
    if (existingUser) {
      throw new BadRequestException(
        `A user with code ${command.username} already exists.`,
      );
    }

    // Use Case 步骤 2: 加密密码
    const hashedPassword = await Password.hash(command.password);

    // Use Case 步骤 3: 创建用户聚合根
    const userCreateProperties: UserCreateProperties = {
      id: UlidGenerator.generate(),
      username: command.username,
      nickName: command.nickName,
      password: hashedPassword.getValue(),
      domain: command.domain,
      status: Status.ENABLED,
      avatar: command.avatar,
      email: command.email,
      phoneNumber: command.phoneNumber,
      createdAt: new Date(),
      createdBy: command.uid,
    };
    const user = new User(userCreateProperties);

    // Use Case 步骤 4: 保存到数据库
    await this.userWriteRepository.save(user);

    // Use Case 步骤 5: 发布领域事件
    await user.created();
    this.publisher.mergeObjectContext(user);
    user.commit();
  }
}
```

### 3.2 读操作 Use Case：查询用户

```typescript
// lib/bounded-contexts/iam/authentication/application/query-handlers/find-user-by-id.query.handler.ts
@QueryHandler(FindUserByIdQuery)
export class FindUserByIdQueryHandler
  implements IQueryHandler<FindUserByIdQuery, UserProperties | null>
{
  @Inject(UserReadRepoPortToken)
  private readonly repository: UserReadRepoPort;

  async execute(query: FindUserByIdQuery): Promise<UserProperties | null> {
    // Use Case: 根据 ID 查询用户
    return this.repository.findUserById(query.id);
  }
}
```

## 4. 端口接口定义

### 4.1 写入仓储端口

```typescript
// lib/bounded-contexts/iam/authentication/ports/user.write.repo-port.ts
export interface UserWriteRepoPort {
  save(user: User): Promise<void>;
  update(user: User): Promise<void>;
  deleteById(id: string): Promise<void>;
}
```

### 4.2 读取仓储端口

```typescript
// lib/bounded-contexts/iam/authentication/ports/user.read.repo-port.ts
export interface UserReadRepoPort {
  findUserById(id: string): Promise<UserProperties | null>;
  getUserByUsername(username: string): Promise<Readonly<UserProperties> | null>;
  pageUsers(query: PageUsersQuery): Promise<PaginationResult<UserProperties>>;
}
```

## 5. 适配器实现

### 5.1 写入仓储适配器

```typescript
// infra/bounded-contexts/iam/authentication/repository/user.write.pg.repository.ts
@Injectable()
export class UserWriteRepository implements UserWriteRepoPort {
  constructor(private readonly em: EntityManager) {}

  async save(user: User): Promise<void> {
    // 聚合根 → 数据库实体映射
    const userData = {
      ...user,
      password: user.password.getValue(), // 值对象转换
    };
    const newUser = this.em.create('SysUser', userData);
    await this.em.persistAndFlush(newUser);
  }

  async update(user: User): Promise<void> {
    await this.em.nativeUpdate(
      'SysUser',
      { id: user.id },
      {
        nickName: user.nickName,
        status: user.status,
        avatar: user.avatar,
        email: user.email,
        phoneNumber: user.phoneNumber,
        updatedAt: new Date(),
        updatedBy: user.createdBy,
      },
    );
  }

  async deleteById(id: string): Promise<void> {
    await this.em.nativeDelete('SysUser', { id });
  }
}
```

### 5.2 读取仓储适配器

```typescript
// infra/bounded-contexts/iam/authentication/repository/user.read.pg.repository.ts
@Injectable()
export class UserReadRepository implements UserReadRepoPort {
  constructor(private readonly em: EntityManager) {}

  async findUserById(id: string): Promise<UserProperties | null> {
    const user = await this.em.findOne('SysUser', { id } as FilterQuery<any>);
    return user as UserProperties | null;
  }

  async getUserByUsername(
    username: string,
  ): Promise<Readonly<UserProperties> | null> {
    const user = await this.em.findOne('SysUser', {
      username,
    } as FilterQuery<any>);
    return user as Readonly<UserProperties> | null;
  }

  async pageUsers(
    query: PageUsersQuery,
  ): Promise<PaginationResult<UserProperties>> {
    const where: FilterQuery<any> = {};
    if (query.username) {
      where.username = { $like: `%${query.username}%` };
    }
    const [users, total] = await this.em.findAndCount('SysUser', where, {
      limit: query.size,
      offset: (query.current - 1) * query.size,
    });
    return new PaginationResult<UserProperties>(
      query.current,
      query.size,
      total,
      users as unknown as UserProperties[],
    );
  }
}
```

## 6. 数据库实体

```typescript
// infra/entities/sys-user.entity.ts
@Entity({ tableName: 'sys_user' })
export class SysUser {
  @PrimaryKey()
  id!: string;

  @Property()
  username!: string;

  @Property({ nullable: true })
  password?: string; // Password 值对象 → string

  @Property()
  domain!: string;

  @Property({ type: 'string' })
  status!: Status;

  @Property()
  nickName!: string;

  @Property({ nullable: true })
  avatar?: string | null;

  @Property({ nullable: true })
  email?: string | null;

  @Property({ nullable: true })
  phoneNumber?: string | null;

  @Property()
  createdAt!: Date;

  @Property()
  createdBy!: string;

  @Property({ nullable: true })
  updatedAt?: Date | null;

  @Property({ nullable: true })
  updatedBy?: string | null;
}
```

## 7. 事件处理器

```typescript
// lib/bounded-contexts/iam/authentication/application/event-handlers/user-created.handler.ts
@EventsHandler(UserCreatedEvent)
export class UserCreatedHandler implements IEventHandler<UserCreatedEvent> {
  async handle(event: UserCreatedEvent) {
    // Use Case: 处理用户创建后的后续操作
    // 例如：初始化权限、发送通知等
    Logger.log(`User created: ${event.username} in domain ${event.domain}`);
  }
}
```

## 8. Controller 实现

```typescript
// api/iam/rest/user.controller.ts
@Controller('users')
export class UserController {
  constructor(
    private readonly commandBus: CommandBus,
    private readonly queryBus: QueryBus,
  ) {}

  @Post()
  async createUser(@Body() dto: CreateUserDTO) {
    const command = new UserCreateCommand(
      dto.username,
      dto.password,
      dto.domain,
      dto.nickName,
      this.currentUserId,
    );
    await this.commandBus.execute(command);
  }

  @Get(':id')
  async getUser(@Param('id') id: string) {
    const query = new FindUserByIdQuery(id);
    return await this.queryBus.execute(query);
  }
}
```

## 9. 完整流程总结

### 9.1 创建用户流程

```
1. Controller 接收请求
   ↓
2. 创建 UserCreateCommand
   ↓
3. CommandBus 路由到 UserCreateHandler
   ↓
4. UserCreateHandler 执行 Use Case
   - 验证用户名唯一性
   - 加密密码
   - 创建 User 聚合根
   - 保存到数据库
   - 发布 UserCreatedEvent
   ↓
5. UserCreatedHandler 处理事件
   - 初始化权限
   - 发送通知等
```

### 9.2 查询用户流程

```
1. Controller 接收请求
   ↓
2. 创建 FindUserByIdQuery
   ↓
3. QueryBus 路由到 FindUserByIdQueryHandler
   ↓
4. FindUserByIdQueryHandler 执行 Use Case
   - 调用 ReadRepository
   - 返回用户信息
```

## 10. 学习检查

完成本章学习后，请回答以下问题：

1. 用户管理模块的开发顺序是什么？
2. Password 值对象的作用是什么？
3. UserCreateHandler 的 Use Case 步骤是什么？
4. 如何实现聚合根到数据库实体的映射？

## 11. 下一步

- 学习 [角色管理模块案例](./02-角色管理模块案例.md)
- 完成 [实战练习](./03-实战练习.md)

---

**上一章**：[端口适配器实现](../03-实践篇/04-端口适配器实现.md)  
**下一章**：[角色管理模块案例](./02-角色管理模块案例.md)  
**返回**：[培训大纲](../README.md)
