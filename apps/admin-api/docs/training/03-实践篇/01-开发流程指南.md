# 开发流程指南

## 学习目标

- 掌握正确的开发顺序
- 理解为什么必须先写聚合根
- 掌握完整的开发步骤
- 了解开发检查清单

## 1. 核心原则

### ✅ **正确的开发顺序**

**必须先编写聚合根，然后再编写数据库实体类。**

这是 Clean Architecture 的核心原则，符合依赖倒置原则（Dependency Inversion Principle）。

## 2. 为什么必须先写聚合根？

### 2.1 依赖方向

```
┌─────────────────────────┐
│   Infrastructure Layer  │  ← 依赖领域层
│   (数据库实体)          │
└───────────┬─────────────┘
            │ 依赖
            ↓
┌─────────────────────────┐
│   Domain Layer          │  ← 核心，不依赖任何层
│   (聚合根)              │
└─────────────────────────┘
```

**原则**：

- 领域层是核心，不依赖任何外部层
- 基础设施层依赖领域层，适配领域模型
- 数据库实体应该适配聚合根，而不是反过来

### 2.2 业务驱动

- **聚合根**：反映业务概念和业务规则，是业务的真实表达
- **数据库实体**：技术实现，用于持久化数据

业务应该驱动技术实现，而不是技术实现驱动业务。

### 2.3 可替换性

如果先设计聚合根：

- 可以轻松替换数据库（PostgreSQL → MongoDB）
- 可以替换 ORM 框架
- 领域模型保持独立

## 3. 正确的开发流程

### 3.1 开发步骤

```
步骤 1: 分析业务需求
    ↓
步骤 2: 设计领域模型（聚合根、值对象、领域事件）
    ↓
步骤 3: 编写聚合根代码 ✅ 先做这个！
    lib/bounded-contexts/.../domain/{aggregate}.ts
    ↓
步骤 4: 定义端口接口
    lib/bounded-contexts/.../ports/{repo-port}.ts
    ↓
步骤 5: 设计数据库表结构
    ↓
步骤 6: 编写数据库实体类 ✅ 然后做这个！
    infra/entities/{entity}.entity.ts
    ↓
步骤 7: 实现仓储适配器
    infra/.../repository/{repository}.ts
    ↓
步骤 8: 编写映射逻辑
```

### 3.2 详细流程说明

#### 步骤 1: 分析业务需求

理解业务需求，识别核心业务概念。

**示例**：

- 业务概念：用户（User）
- 业务规则：用户密码必须加密、用户名在域内唯一、用户有状态（启用/禁用）

#### 步骤 2: 设计领域模型

设计聚合根、值对象、领域事件。

**示例**：

```typescript
// 设计思路
- 聚合根：User
- 值对象：Password（封装密码加密和验证逻辑）
- 领域事件：UserCreatedEvent, UserDeletedEvent
- 属性：id, username, password, domain, status, ...
```

#### 步骤 3: 编写聚合根代码 ✅ **从这里开始**

**位置**：`src/lib/bounded-contexts/{context}/{module}/domain/{aggregate}.ts`

**示例**：

```typescript
// lib/bounded-contexts/iam/authentication/domain/user.ts
export class User extends AggregateRoot implements IUser {
  readonly id: string;
  readonly username: string;
  readonly password: Password;  // 值对象
  readonly domain: string;
  readonly status: Status;

  async loginUser(password: string) {
    // 业务逻辑
  }

  async created() {
    this.apply(new UserCreatedEvent(...));
  }
}
```

**关键点**：

- ✅ 先定义属性和业务方法
- ✅ 实现领域逻辑
- ✅ 定义领域事件
- ✅ 不依赖任何数据库相关代码

#### 步骤 4: 定义端口接口

定义仓储接口，指定需要什么功能。

**位置**：`src/lib/bounded-contexts/{context}/{module}/ports/{module}.read.repo-port.ts`

**示例**：

```typescript
// ports/user.write.repo-port.ts
export interface UserWriteRepoPort {
  save(user: User): Promise<void>;
  update(user: User): Promise<void>;
  deleteById(id: string): Promise<void>;
}
```

**关键点**：

- ✅ 接口使用领域模型（User），不是数据库实体
- ✅ 定义需要什么功能，不关心如何实现

#### 步骤 5: 设计数据库表结构

根据聚合根设计数据库表结构。

**示例**：

```sql
-- 根据 User 聚合根设计表结构
CREATE TABLE sys_user (
  id VARCHAR PRIMARY KEY,
  username VARCHAR NOT NULL,
  password VARCHAR,           -- Password 值对象存储为字符串
  domain VARCHAR NOT NULL,
  status VARCHAR NOT NULL,
  -- ...
);
```

#### 步骤 6: 编写数据库实体类 ✅ **然后写这个**

**位置**：`src/infra/entities/{entity}.entity.ts`

**示例**：

```typescript
// infra/entities/sys-user.entity.ts
@Entity({ tableName: 'sys_user' })
export class SysUser {
  @PrimaryKey()
  id!: string;

  @Property()
  username!: string;

  @Property({ nullable: true })
  password?: string; // Password 值对象 → string

  @Property()
  domain!: string;

  // ...
}
```

#### 步骤 7: 实现仓储适配器

实现仓储接口，编写映射逻辑。

**位置**：`src/infra/bounded-contexts/{context}/{module}/repository/{module}.write.pg.repository.ts`

**示例**：

```typescript
// infra/bounded-contexts/iam/authentication/repository/user.write.pg.repository.ts
@Injectable()
export class UserWriteRepository implements UserWriteRepoPort {
  constructor(private readonly em: EntityManager) {}

  async save(user: User): Promise<void> {
    // 聚合根 → 数据库实体
    const userData = {
      ...user,
      password: user.password.getValue(), // 值对象转换
    };
    const newUser = this.em.create('SysUser', userData);
    await this.em.persistAndFlush(newUser);
  }
}
```

## 4. 开发检查清单

### 4.1 聚合根开发清单

- [ ] 分析业务需求，识别业务概念
- [ ] 设计聚合根属性和业务方法
- [ ] 识别值对象（Password、Money 等）
- [ ] 定义领域事件
- [ ] 实现业务逻辑和业务规则
- [ ] 编写工厂方法（fromCreate、fromUpdate 等）
- [ ] 不依赖任何数据库或 ORM 代码

### 4.2 数据库实体开发清单

- [ ] 根据聚合根设计数据库表结构
- [ ] 编写数据库实体类，字段对应聚合根属性
- [ ] 值对象字段使用基础类型（string、number 等）
- [ ] 使用 ORM 装饰器（@Entity、@Property 等）
- [ ] 考虑数据库约束（唯一索引、外键等）
- [ ] 编写数据库迁移脚本

### 4.3 仓储适配器开发清单

- [ ] 实现端口接口
- [ ] 编写聚合根到数据库实体的映射逻辑
- [ ] 处理值对象的转换（getValue()）
- [ ] 实现写入操作（save、update、delete）
- [ ] 实现读取操作（find、query）
- [ ] 注册依赖注入

## 5. 常见错误

### 5.1 ❌ 错误：先写数据库实体

```typescript
// ❌ 错误：先设计数据库实体
@Entity({ tableName: 'sys_product' })
export class SysProduct {
  @PrimaryKey()
  id!: number; // 使用自增 ID

  @Property()
  name!: string;
}

// ❌ 然后聚合根受数据库限制
export class Product extends AggregateRoot {
  readonly id: number; // 被迫使用自增 ID，不合理
  readonly name: string;
}
```

### 5.2 ✅ 正确：先写聚合根

```typescript
// ✅ 正确：先设计聚合根（业务驱动）
export class Product extends AggregateRoot {
  readonly id: string; // 使用 ULID，业务需求
  readonly name: string;
  readonly price: Money; // 值对象，封装业务逻辑
}

// ✅ 然后数据库实体适配聚合根
@Entity({ tableName: 'sys_product' })
export class SysProduct {
  @PrimaryKey()
  id!: string; // 适配 ULID

  @Property()
  name!: string;

  @Property()
  price!: number; // Money 值对象存储为 number
}
```

## 6. 学习检查

完成本章学习后，请回答以下问题：

1. 为什么必须先写聚合根？
2. 正确的开发顺序是什么？
3. 聚合根开发需要完成哪些步骤？
4. 数据库实体如何适配聚合根？

## 7. 下一步

- 学习 [聚合根开发](./02-聚合根开发.md)
- 查看 [开发流程文档](../../DEVELOPMENT-WORKFLOW.md)

---

**上一章**：[项目结构](../01-基础篇/03-项目结构.md)  
**下一章**：[聚合根开发](./02-聚合根开发.md)  
**返回**：[培训大纲](../README.md)
