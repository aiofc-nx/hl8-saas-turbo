# 数据库迁移指南：PostgreSQL → MongoDB

## 学习目标

- 理解架构设计带来的数据库可替换性
- 掌握从 PostgreSQL 迁移到 MongoDB 的步骤
- 理解为什么可以保持 ORM 不变（MikroORM）
- 了解迁移的注意事项

## 1. 架构优势：数据库可替换性

### 1.1 为什么可以轻松替换数据库？

**核心原因**：Clean Architecture 和端口适配器模式带来的解耦。

```
应用层（Application Layer）
    ↓ 依赖端口接口（Port）
基础设施层（Infrastructure Layer）
    ↓ 实现适配器（Adapter）
数据库（PostgreSQL / MongoDB）
```

**关键点**：

- 应用层只依赖端口接口，不依赖具体数据库
- 基础设施层实现适配器，可以替换实现
- ORM 框架（MikroORM）支持多种数据库

### 1.2 架构设计带来的优势

**当前架构设计**：

- ✅ 领域层不依赖数据库
- ✅ 应用层通过端口接口访问数据
- ✅ 基础设施层实现适配器

**迁移优势**：

- ✅ 只需要修改基础设施层的适配器实现
- ✅ 应用层代码无需修改
- ✅ 领域层代码无需修改
- ✅ ORM 框架（MikroORM）支持 MongoDB

## 2. MikroORM 对 MongoDB 的支持

### 2.1 MikroORM 多数据库支持

**MikroORM 支持多种数据库**：

- PostgreSQL
- MySQL
- SQLite
- MongoDB
- 等

**关键点**：使用相同的 ORM API，只需要修改配置。

### 2.2 配置差异

**PostgreSQL 配置**：

```typescript
// mikro-orm.config.ts
export default {
  type: 'postgresql',
  host: 'localhost',
  port: 5432,
  user: 'postgres',
  password: 'password',
  dbName: 'iam_db',
  // ...
};
```

**MongoDB 配置**：

```typescript
// mikro-orm.config.ts
export default {
  type: 'mongo',
  clientUrl: 'mongodb://localhost:27017',
  dbName: 'iam_db',
  // ...
};
```

## 3. 迁移步骤

### 3.1 迁移准备

#### 步骤 1: 分析现有代码

**需要修改的部分**：

- ✅ 数据库配置（mikro-orm.config.ts）
- ✅ 数据库实体装饰器（@Entity、@Property）
- ✅ 仓储实现中的查询语法（如果需要）
- ❌ 应用层代码（无需修改）
- ❌ 领域层代码（无需修改）

#### 步骤 2: 检查 MikroORM 兼容性

**MongoDB 与 PostgreSQL 的差异**：

- MongoDB 是文档数据库，不需要表结构
- 某些 SQL 特性在 MongoDB 中不可用
- 查询语法可能略有不同

**MikroORM 的处理**：

- MikroORM 提供了统一的 API
- 大部分操作可以无缝迁移
- 某些复杂查询可能需要调整

### 3.2 迁移实施

#### 步骤 1: 修改数据库配置

```typescript
// mikro-orm.config.ts
export default {
  // 从 PostgreSQL 配置
  // type: 'postgresql',
  // host: 'localhost',
  // port: 5432,

  // 改为 MongoDB 配置
  type: 'mongo',
  clientUrl: 'mongodb://localhost:27017',
  dbName: 'iam_db',

  // 其他配置保持不变
  entities: [
    /* ... */
  ],
  // ...
};
```

#### 步骤 2: 调整数据库实体

**PostgreSQL 实体**：

```typescript
@Entity({ tableName: 'sys_user' })
export class SysUser {
  @PrimaryKey()
  id!: string;

  @Property()
  username!: string;
}
```

**MongoDB 实体**（基本不变）：

```typescript
@Entity({ collection: 'sys_user' }) // collection 替代 tableName
export class SysUser {
  @PrimaryKey()
  id!: string;

  @Property()
  username!: string;
}
```

**关键变化**：

- `tableName` → `collection`（仅名称变化，功能相同）
- 其他装饰器基本不变

#### 步骤 3: 检查仓储实现

**大部分代码无需修改**：

```typescript
// 这些代码在 PostgreSQL 和 MongoDB 中都适用
@Injectable()
export class UserReadRepository implements UserReadRepoPort {
  constructor(private readonly em: EntityManager) {}

  async findUserById(id: string): Promise<UserProperties | null> {
    // MikroORM API 统一，无需修改
    const user = await this.em.findOne('SysUser', { id });
    return user as UserProperties | null;
  }

  async pageUsers(query: PageUsersQuery): Promise<PaginationResult<UserProperties>> {
    // MikroORM API 统一，无需修改
    const [users, total] = await this.em.findAndCount('SysUser', where, {
      limit: query.size,
      offset: (query.current - 1) * query.size,
    });
    return new PaginationResult(...);
  }
}
```

**可能需要调整的部分**：

```typescript
// 复杂查询可能需要调整
// PostgreSQL 特定语法
where.username = { $like: `%${query.username}%` };

// MongoDB 中可以使用相同语法（MikroORM 会转换）
// 或者使用 MongoDB 原生语法
where.username = { $regex: query.username, $options: 'i' };
```

#### 步骤 4: 数据迁移

**数据迁移策略**：

1. **导出 PostgreSQL 数据**

   ```bash
   pg_dump -U postgres iam_db > backup.sql
   ```

2. **转换为 MongoDB 格式**
   - 编写迁移脚本
   - 或使用数据迁移工具

3. **导入 MongoDB**
   ```bash
   mongoimport --db iam_db --collection sys_user --file users.json
   ```

### 3.3 迁移验证

#### 验证步骤

1. **单元测试**：运行所有单元测试
2. **集成测试**：运行集成测试
3. **功能测试**：测试所有业务功能
4. **性能测试**：验证性能是否满足要求

## 4. 架构设计带来的优势

### 4.1 无需修改的代码

**应用层代码**（无需修改）：

```typescript
// Command Handler - 无需修改
@CommandHandler(UserCreateCommand)
export class UserCreateHandler {
  @Inject(UserWriteRepoPortToken)
  private readonly repository: UserWriteRepoPort;  // 接口不变

  async execute(command: UserCreateCommand) {
    // 代码无需修改
    const user = new User(...);
    await this.repository.save(user);  // 接口方法不变
  }
}
```

**领域层代码**（无需修改）：

```typescript
// 聚合根 - 无需修改
export class User extends AggregateRoot {
  // 所有代码保持不变
}
```

**端口接口**（无需修改）：

```typescript
// 端口接口 - 无需修改
export interface UserWriteRepoPort {
  save(user: User): Promise<void>; // 接口定义不变
}
```

### 4.2 需要修改的代码

**基础设施层代码**（需要修改）：

```typescript
// 适配器实现 - 只需要修改实现细节
@Injectable()
export class UserWriteRepository implements UserWriteRepoPort {
  constructor(private readonly em: EntityManager) {}

  async save(user: User): Promise<void> {
    // 实现细节可能略有不同，但接口方法签名不变
    const userData = {
      ...user,
      password: user.password.getValue(),
    };
    // MikroORM API 统一，大部分代码不变
    const newUser = this.em.create('SysUser', userData);
    await this.em.persistAndFlush(newUser);
  }
}
```

## 5. 迁移检查清单

### 5.1 配置检查

- [ ] 修改 `mikro-orm.config.ts` 中的数据库类型
- [ ] 修改数据库连接配置
- [ ] 更新环境变量配置
- [ ] 检查实体装饰器（`tableName` → `collection`）

### 5.2 代码检查

- [ ] 检查仓储实现中的查询语法
- [ ] 检查是否有 PostgreSQL 特定语法
- [ ] 验证 MikroORM API 兼容性
- [ ] 检查事务处理（MongoDB 事务支持）

### 5.3 数据迁移

- [ ] 导出 PostgreSQL 数据
- [ ] 转换数据格式
- [ ] 导入 MongoDB
- [ ] 验证数据完整性

### 5.4 测试验证

- [ ] 运行单元测试
- [ ] 运行集成测试
- [ ] 功能测试
- [ ] 性能测试

## 6. 注意事项

### 6.1 数据库差异

**PostgreSQL vs MongoDB**：

| 特性     | PostgreSQL | MongoDB       |
| -------- | ---------- | ------------- |
| 数据模型 | 关系型     | 文档型        |
| 事务支持 | 完整支持   | 4.0+ 支持     |
| 查询语法 | SQL        | MongoDB Query |
| 索引     | B-tree     | 多种索引类型  |

### 6.2 MikroORM 兼容性

**MikroORM 的优势**：

- ✅ 统一的 API，大部分代码无需修改
- ✅ 自动处理数据库差异
- ✅ 支持事务（MongoDB 4.0+）

**需要注意**：

- ⚠️ 某些复杂查询可能需要调整
- ⚠️ 事务处理方式可能略有不同
- ⚠️ 性能特性可能不同

### 6.3 数据迁移

**数据格式转换**：

- PostgreSQL 的关系型数据 → MongoDB 的文档型数据
- 可能需要调整数据结构
- 需要验证数据完整性

## 7. 迁移示例

### 7.1 配置迁移

**之前（PostgreSQL）**：

```typescript
export default {
  type: 'postgresql',
  host: 'localhost',
  port: 5432,
  user: 'postgres',
  password: 'password',
  dbName: 'iam_db',
};
```

**之后（MongoDB）**：

```typescript
export default {
  type: 'mongo',
  clientUrl: 'mongodb://localhost:27017',
  dbName: 'iam_db',
};
```

### 7.2 实体迁移

**之前（PostgreSQL）**：

```typescript
@Entity({ tableName: 'sys_user' })
export class SysUser {
  @PrimaryKey()
  id!: string;
}
```

**之后（MongoDB）**：

```typescript
@Entity({ collection: 'sys_user' }) // 仅名称变化
export class SysUser {
  @PrimaryKey()
  id!: string;
}
```

### 7.3 仓储实现（基本不变）

```typescript
// 大部分代码保持不变
@Injectable()
export class UserReadRepository implements UserReadRepoPort {
  constructor(private readonly em: EntityManager) {}

  async findUserById(id: string): Promise<UserProperties | null> {
    // MikroORM API 统一，代码无需修改
    const user = await this.em.findOne('SysUser', { id });
    return user as UserProperties | null;
  }
}
```

## 8. 架构优势总结

### 8.1 可替换性

**优势**：

- ✅ 可以轻松替换数据库
- ✅ 应用层代码无需修改
- ✅ 领域层代码无需修改
- ✅ 只需要修改基础设施层

### 8.2 维护成本

**迁移成本**：

- 配置修改：低（只需修改配置文件）
- 代码修改：低（大部分代码无需修改）
- 测试验证：中（需要全面测试）

### 8.3 风险控制

**风险**：

- ⚠️ 数据迁移风险（需要仔细验证）
- ⚠️ 性能差异（需要性能测试）
- ⚠️ 功能差异（需要功能测试）

**缓解措施**：

- ✅ 充分的测试
- ✅ 逐步迁移
- ✅ 回滚方案

## 9. 学习检查

完成本章学习后，请回答以下问题：

1. 为什么可以轻松替换数据库？
2. 迁移时需要修改哪些代码？
3. 哪些代码无需修改？
4. MikroORM 如何支持多数据库？
5. 迁移的注意事项是什么？

## 10. 下一步

- 学习 [用户管理模块案例](../04-案例篇/01-用户管理模块案例.md)
- 查看 [端口适配器实现](./04-端口适配器实现.md)

---

**上一章**：[聚合根与数据库实体映射](./05-聚合根与数据库实体映射.md)  
**下一章**：[用户管理模块案例](../04-案例篇/01-用户管理模块案例.md)  
**返回**：[培训大纲](../README.md)
