# 事件溯源（Event Sourcing）详解

## 学习目标

- 深入理解事件溯源的原理和优势
- 理解事件溯源与 CQRS、EDA 的结合
- 掌握事件存储的设计和实现
- 理解状态重建机制
- 了解快照策略

## 1. 事件溯源原理

### 1.1 核心思想

**事件溯源（Event Sourcing, ES）** 的核心思想是：

**不存储当前状态，而是存储所有发生的事件，通过重放事件来重建当前状态。**

### 1.2 与传统方式的对比

#### 传统方式（当前状态存储）

```
用户创建 → 保存用户状态到数据库
用户更新 → 更新用户状态
用户删除 → 删除用户记录

问题：
- 丢失历史记录
- 无法追溯变更历史
- 难以审计
```

#### 事件溯源方式

```
用户创建 → 保存 UserCreatedEvent
用户更新 → 保存 UserUpdatedEvent
用户删除 → 保存 UserDeletedEvent

优势：
- 完整的历史记录
- 可以追溯任何时间点的状态
- 易于审计
- 可以重建状态
```

### 1.3 状态重建

**通过重放事件重建状态**：

```
初始状态（空）
    ↓
UserCreatedEvent → 状态1
    ↓
UserUpdatedEvent → 状态2
    ↓
UserUpdatedEvent → 状态3（当前状态）
```

## 2. 与现有架构的结合

### 2.1 架构组合

```
Clean Architecture（清洁架构）
    +
CQRS（命令查询职责分离）
    +
事件驱动架构（EDA）
    +
事件溯源（Event Sourcing, ES）
```

### 2.2 与 CQRS 的结合

**CQRS + Event Sourcing** 是经典的组合：

- **写操作（Command）**：保存事件到事件存储
- **读操作（Query）**：从读取模型查询（或从事件重建）

**优势**：

- 写操作只追加事件，性能好
- 读操作可以从读取模型查询，性能好
- 可以异步构建读取模型

### 2.3 与 EDA 的结合

**EDA + Event Sourcing** 天然契合：

- **领域事件**：既是事件驱动的事件，也是事件溯源的事件
- **事件存储**：统一存储所有领域事件
- **事件重放**：可以重放事件处理副作用

## 3. 事件存储（Event Store）

### 3.1 事件存储设计

**事件表结构**：

```sql
CREATE TABLE domain_events (
  id VARCHAR PRIMARY KEY,
  aggregate_id VARCHAR NOT NULL,
  aggregate_type VARCHAR NOT NULL,
  event_type VARCHAR NOT NULL,
  event_data JSONB NOT NULL,
  occurred_at TIMESTAMP NOT NULL,
  version INT NOT NULL,
  metadata JSONB,
  INDEX idx_aggregate (aggregate_id, aggregate_type),
  INDEX idx_occurred_at (occurred_at)
);
```

### 3.2 事件存储接口

```typescript
// 事件存储端口接口
export interface EventStorePort {
  /**
   * 保存事件
   *
   * @param aggregateId - 聚合 ID
   * @param aggregateType - 聚合类型
   * @param events - 事件列表
   * @param expectedVersion - 期望的版本号（乐观锁）
   */
  saveEvents(
    aggregateId: string,
    aggregateType: string,
    events: IEvent[],
    expectedVersion: number,
  ): Promise<void>;

  /**
   * 获取聚合的所有事件
   *
   * @param aggregateId - 聚合 ID
   * @param aggregateType - 聚合类型
   */
  getEvents(aggregateId: string, aggregateType: string): Promise<IEvent[]>;

  /**
   * 获取事件流（从指定版本开始）
   *
   * @param aggregateId - 聚合 ID
   * @param aggregateType - 聚合类型
   * @param fromVersion - 起始版本号
   */
  getEventStream(
    aggregateId: string,
    aggregateType: string,
    fromVersion?: number,
  ): Promise<EventStream>;
}
```

### 3.3 事件存储实现

```typescript
// 事件存储适配器实现
@Injectable()
export class EventStoreRepository implements EventStorePort {
  constructor(private readonly em: EntityManager) {}

  async saveEvents(
    aggregateId: string,
    aggregateType: string,
    events: IEvent[],
    expectedVersion: number,
  ): Promise<void> {
    // 乐观锁检查
    const currentVersion = await this.getCurrentVersion(
      aggregateId,
      aggregateType,
    );
    if (currentVersion !== expectedVersion) {
      throw new ConcurrencyException('Version mismatch');
    }

    // 保存事件
    for (let i = 0; i < events.length; i++) {
      const event = events[i];
      const eventRecord = {
        id: UlidGenerator.generate(),
        aggregateId,
        aggregateType,
        eventType: event.constructor.name,
        eventData: JSON.stringify(event),
        occurredAt: new Date(),
        version: expectedVersion + i + 1,
      };
      await this.em.persistAndFlush(eventRecord);
    }
  }

  async getEvents(
    aggregateId: string,
    aggregateType: string,
  ): Promise<IEvent[]> {
    const events = await this.em.find(
      'DomainEvent',
      {
        aggregateId,
        aggregateType,
      },
      {
        orderBy: { version: 'ASC' },
      },
    );

    return events.map((event) => this.deserializeEvent(event));
  }
}
```

## 4. 状态重建

### 4.1 从事件重建聚合根

```typescript
export class User extends AggregateRoot {
  // 从事件重建聚合根
  static async fromEvents(
    eventStore: EventStorePort,
    userId: string,
  ): Promise<User> {
    const events = await eventStore.getEvents(userId, 'User');

    let user = null;
    for (const event of events) {
      user = User.applyEvent(user, event);
    }

    return user;
  }

  // 应用事件重建状态
  private static applyEvent(user: User | null, event: IEvent): User {
    switch (event.constructor.name) {
      case 'UserCreatedEvent':
        return new User({
          id: event.userId,
          username: event.username,
          domain: event.domain,
          status: Status.ENABLED,
          // ...
        });
      case 'UserUpdatedEvent':
        return { ...user, ...event.data };
      case 'UserStatusChangedEvent':
        return { ...user, status: event.status };
      default:
        return user;
    }
  }
}
```

### 4.2 在 Command Handler 中使用

```typescript
@CommandHandler(UserUpdateCommand)
export class UserUpdateHandler implements ICommandHandler {
  constructor(
    private readonly eventStore: EventStorePort,
    private readonly publisher: EventPublisher,
  ) {}

  async execute(command: UserUpdateCommand) {
    // 1. 从事件重建聚合根
    const user = await User.fromEvents(this.eventStore, command.userId);

    // 2. 执行业务操作
    user.updateNickName(command.nickName);

    // 3. 发布新事件
    await user.updated();

    // 4. 保存新事件到事件存储
    await this.eventStore.saveEvents(
      user.id,
      'User',
      user.getUncommittedEvents(),
      user.version,
    );

    // 5. 提交事件到事件总线
    this.publisher.mergeObjectContext(user);
    user.commit();
  }
}
```

## 5. 快照（Snapshot）

### 5.1 快照的作用

**问题**：如果事件很多，重建状态会很慢。

**解决方案**：定期创建快照，从快照开始重建。

```
事件1 → 事件2 → ... → 事件1000 → [快照] → 事件1001 → ... → 当前状态
                                    ↑
                              从快照开始重建（只需重放 1001 之后的事件）
```

### 5.2 快照实现

```typescript
// 快照存储接口
export interface SnapshotStorePort {
  saveSnapshot(
    aggregateId: string,
    aggregateType: string,
    snapshot: any,
    version: number,
  ): Promise<void>;
  getSnapshot(
    aggregateId: string,
    aggregateType: string,
  ): Promise<{ snapshot: any; version: number } | null>;
}

// 快照策略
export class SnapshotStrategy {
  // 每 N 个事件创建一个快照
  shouldCreateSnapshot(
    currentVersion: number,
    snapshotInterval: number,
  ): boolean {
    return currentVersion % snapshotInterval === 0;
  }
}

// 使用快照重建
export class User extends AggregateRoot {
  static async fromEventsWithSnapshot(
    eventStore: EventStorePort,
    snapshotStore: SnapshotStorePort,
    userId: string,
  ): Promise<User> {
    // 1. 尝试获取快照
    const snapshot = await snapshotStore.getSnapshot(userId, 'User');

    let user = snapshot ? snapshot.snapshot : null;
    const fromVersion = snapshot ? snapshot.version + 1 : 1;

    // 2. 获取快照之后的事件
    const events = await eventStore.getEventStream(userId, 'User', fromVersion);

    // 3. 从快照开始重放事件
    for (const event of events) {
      user = User.applyEvent(user, event);
    }

    return user;
  }
}
```

## 6. 读取模型构建

### 6.1 从事件构建读取模型

```typescript
// 事件处理器：构建读取模型
@EventsHandler(UserCreatedEvent)
export class UserReadModelBuilder implements IEventHandler {
  constructor(
    @Inject(UserReadRepoPortToken)
    private readonly readModelRepository: UserReadRepoPort,
  ) {}

  async handle(event: UserCreatedEvent) {
    // 从事件构建读取模型
    await this.readModelRepository.save({
      id: event.userId,
      username: event.username,
      domain: event.domain,
      status: Status.ENABLED,
      createdAt: new Date(),
    });
  }
}
```

### 6.2 读取模型更新

```typescript
@EventsHandler(UserUpdatedEvent)
export class UserReadModelUpdater implements IEventHandler {
  async handle(event: UserUpdatedEvent) {
    // 更新读取模型
    await this.readModelRepository.update(event.userId, {
      nickName: event.nickName,
      status: event.status,
      updatedAt: new Date(),
    });
  }
}
```

## 7. 事件溯源的优势

### 7.1 完整的历史记录

- ✅ 所有变更都有记录
- ✅ 可以追溯任何时间点的状态
- ✅ 完整的审计日志

### 7.2 时间旅行

- ✅ 可以查看任何历史时间点的状态
- ✅ 可以重放事件到特定时间点
- ✅ 支持时间点查询

### 7.3 调试和问题排查

- ✅ 可以重放事件重现问题
- ✅ 可以查看完整的变更历史
- ✅ 易于调试

### 7.4 与 CQRS 完美结合

- ✅ 写操作只追加事件，性能好
- ✅ 读操作从读取模型查询，性能好
- ✅ 可以异步构建读取模型

## 8. 事件溯源的挑战

### 8.1 事件版本管理

**挑战**：事件结构可能变化

**解决方案**：

- 事件版本化
- 事件迁移策略
- 向后兼容

### 8.2 快照管理

**挑战**：快照需要与事件同步

**解决方案**：

- 定期创建快照
- 快照验证
- 快照重建

### 8.3 性能考虑

**挑战**：重建状态可能很慢

**解决方案**：

- 使用快照
- 异步构建读取模型
- 缓存重建的状态

## 9. 实施建议

### 9.1 渐进式实施

**阶段 1**：保持现有架构，添加事件存储

- 保存事件到事件存储
- 同时保存当前状态（双重写入）
- 验证事件存储功能

**阶段 2**：实现事件重放

- 实现从事件重建状态的逻辑
- 验证重建的状态与当前状态一致
- 测试状态重建性能

**阶段 3**：完全切换到事件溯源

- 移除当前状态存储（或保留作为缓存）
- 完全依赖事件存储
- 优化性能

### 9.2 适用场景

**适合使用事件溯源**：

- ✅ 需要完整审计日志
- ✅ 需要时间旅行功能
- ✅ 需要追溯历史
- ✅ 复杂的业务领域
- ✅ 需要完整的变更历史

**不适合使用事件溯源**：

- ❌ 简单的 CRUD 应用
- ❌ 不需要历史记录
- ❌ 性能要求极高的场景
- ❌ 事件很少的场景

## 10. 完整示例

### 10.1 用户创建流程（含事件溯源）

```typescript
// 1. Command Handler
@CommandHandler(UserCreateCommand)
export class UserCreateHandler implements ICommandHandler {
  constructor(
    private readonly eventStore: EventStorePort,
    private readonly publisher: EventPublisher,
  ) {}

  async execute(command: UserCreateCommand) {
    // 1. 创建聚合根
    const user = new User({...});

    // 2. 发布领域事件
    await user.created();

    // 3. 保存事件到事件存储（事件溯源）
    await this.eventStore.saveEvents(
      user.id,
      'User',
      user.getUncommittedEvents(),
      0,  // 初始版本
    );

    // 4. 提交事件到事件总线（用于事件处理）
    this.publisher.mergeObjectContext(user);
    user.commit();
  }
}
```

### 10.2 用户更新流程（含事件溯源）

```typescript
@CommandHandler(UserUpdateCommand)
export class UserUpdateHandler implements ICommandHandler {
  async execute(command: UserUpdateCommand) {
    // 1. 从事件重建聚合根
    const user = await User.fromEvents(this.eventStore, command.userId);

    // 2. 执行业务操作
    user.updateNickName(command.nickName);

    // 3. 发布更新事件
    await user.updated();

    // 4. 保存新事件到事件存储
    await this.eventStore.saveEvents(
      user.id,
      'User',
      user.getUncommittedEvents(),
      user.version, // 当前版本
    );

    // 5. 提交事件到事件总线
    this.publisher.mergeObjectContext(user);
    user.commit();
  }
}
```

## 11. 学习检查

完成本章学习后，请回答以下问题：

1. 事件溯源的核心思想是什么？
2. 如何从事件重建状态？
3. 快照的作用是什么？
4. 事件溯源与 CQRS 如何结合？
5. 事件溯源的优势和挑战是什么？

## 12. 下一步

- 学习 [领域驱动设计详解](./05-领域驱动设计详解.md)
- 查看 [事件溯源架构扩展文档](../../EVENT-SOURCING.md)

---

**上一章**：[事件驱动架构详解](./03-事件驱动架构详解.md)  
**下一章**：[领域驱动设计详解](./05-领域驱动设计详解.md)  
**返回**：[培训大纲](../README.md)
