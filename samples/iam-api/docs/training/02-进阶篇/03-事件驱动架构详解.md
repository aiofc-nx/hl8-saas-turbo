# 事件驱动架构详解

## 学习目标

- 深入理解事件驱动架构的原理
- 理解领域事件的概念和设计
- 掌握事件发布和处理的流程
- 理解最终一致性

## 1. 事件驱动架构原理

### 1.1 核心思想

**事件驱动架构（Event-Driven Architecture, EDA）** 的核心思想是：

**通过领域事件实现模块间解耦和异步处理。**

### 1.2 关键组件

- **领域事件（Domain Event）**：表示领域内发生的业务事件
- **事件发布（Event Publishing）**：将事件发送到事件总线
- **事件处理（Event Handling）**：订阅并处理事件
- **事件总线（Event Bus）**：分发事件给所有订阅者

## 2. 领域事件

### 2.1 事件定义

**定义**：领域内发生的、对业务有重要意义的事情。

**特点**：

- 不可变（immutable）
- 使用过去时命名
- 包含足够的信息

**示例**：

```typescript
export class UserCreatedEvent implements IEvent {
  constructor(
    public readonly userId: string,
    public readonly username: string,
    public readonly domain: string,
  ) {}
}

export class UserDeletedEvent implements IEvent {
  constructor(
    public readonly userId: string,
    public readonly username: string,
    public readonly domain: string,
  ) {}
}
```

### 2.2 事件命名规范

**规范**：使用过去时，表示已发生的事情。

**示例**：

- `UserCreated` - 用户已创建
- `UserDeleted` - 用户已删除
- `RoleDeleted` - 角色已删除
- `TokenGenerated` - 令牌已生成
- `RefreshTokenUsed` - 刷新令牌已使用

## 3. 事件发布

### 3.1 发布流程

**流程**：

1. 聚合根通过 `apply()` 方法应用事件
2. 事件存储在聚合根的未提交事件列表中
3. 调用 `commit()` 方法将事件提交到事件总线
4. 事件总线分发事件给所有订阅者

### 3.2 代码示例

```typescript
// 1. 聚合根发布事件
export class User extends AggregateRoot {
  async created() {
    this.apply(new UserCreatedEvent(this.id, this.username, this.domain));
  }
}

// 2. 在 Command Handler 中提交事件
@CommandHandler(UserCreateCommand)
export class UserCreateHandler {
  async execute(command: UserCreateCommand) {
    const user = new User(...);
    await this.repository.save(user);

    // 发布事件
    await user.created();

    // 合并上下文并提交事件
    this.publisher.mergeObjectContext(user);
    user.commit();  // 提交事件到事件总线
  }
}
```

### 3.3 事件发布特点

- **同步发布**：事件在事务内发布
- **事务一致性**：事件发布与数据保存在同一事务中
- **自动分发**：事件总线自动分发事件给订阅者

## 4. 事件处理

### 4.1 事件处理器

**定义**：订阅并处理特定类型的事件。

**特点**：

- 异步执行，不阻塞主流程
- 可以并行处理多个事件
- 失败可以重试
- 可以发布新的事件

**示例**：

```typescript
@EventsHandler(UserCreatedEvent)
export class UserCreatedHandler implements IEventHandler<UserCreatedEvent> {
  constructor(
    private readonly roleService: RoleService,
    private readonly notificationService: NotificationService,
  ) {}

  /**
   * Use Case: 处理用户创建后的后续操作
   *
   * 用例步骤：
   * 1. 初始化用户默认权限
   * 2. 发送欢迎通知
   */
  async handle(event: UserCreatedEvent) {
    // 步骤 1: 初始化用户默认权限
    await this.roleService.assignDefaultRole(event.userId, event.domain);

    // 步骤 2: 发送欢迎通知
    await this.notificationService.sendWelcomeEmail(event.userId);
  }
}
```

### 4.2 事件处理流程

```
事件发布
    ↓
事件总线
    ↓
事件分发
    ↓
事件处理器（异步处理）
    ↓
执行副作用（日志、通知等）
```

## 5. 事件流设计

### 5.1 用户创建事件流

```
1. Controller 接收请求
   ↓
2. 创建 UserCreateCommand
   ↓
3. CommandHandler 执行命令
   ↓
4. 创建 User 聚合根
   ↓
5. 保存到数据库
   ↓
6. User.created() 发布 UserCreatedEvent
   ↓
7. user.commit() 提交事件到事件总线
   ↓
8. 事件总线分发事件
   ↓
9. UserCreatedHandler 处理事件（异步）
   - 初始化权限
   - 发送通知
```

### 5.2 事件链

**场景**：一个事件可以触发另一个事件

```
UserCreatedEvent
    ↓
UserCreatedHandler
    ↓
RoleAssignedEvent (新事件)
    ↓
RoleAssignedHandler
    ↓
PermissionUpdatedEvent (新事件)
```

## 6. 最终一致性

### 6.1 概念

**定义**：系统通过异步事件处理，最终达到一致的状态。

**特点**：

- 不是强一致性，而是最终一致性
- 通过异步事件处理实现
- 系统最终会达到一致状态

### 6.2 示例

**场景**：用户创建后初始化权限

```
1. 用户创建（立即完成）
   ↓
2. 用户创建事件发布（异步）
   ↓
3. 权限初始化（异步处理）
   ↓
4. 系统最终达到一致状态
```

**优势**：

- 提升系统响应性
- 解耦模块
- 支持分布式系统

## 7. 事件驱动架构的优势

### 7.1 解耦

**优势**：发布者和订阅者不需要知道对方的存在。

**示例**：

- `User` 聚合根发布 `UserCreatedEvent`
- `UserCreatedHandler` 订阅并处理事件
- 两者不需要直接依赖

### 7.2 可扩展性

**优势**：可以轻松添加新的事件处理器。

**示例**：

```typescript
// 可以添加新的事件处理器，不影响现有代码
@EventsHandler(UserCreatedEvent)
export class UserCreatedAuditHandler implements IEventHandler {
  async handle(event: UserCreatedEvent) {
    // 记录审计日志
  }
}
```

### 7.3 异步处理

**优势**：提升系统响应性。

**示例**：

- 用户创建操作立即返回
- 权限初始化、通知发送等异步处理
- 不阻塞主流程

### 7.4 最终一致性

**优势**：通过事件实现系统间的最终一致性。

**示例**：

- 用户创建后，通过事件同步到其他系统
- 最终所有系统达到一致状态

## 8. 事件设计最佳实践

### 8.1 ✅ 推荐做法

1. **事件命名使用过去时**

   ```typescript
   UserCreatedEvent; // ✅ 正确
   CreateUserEvent; // ❌ 错误
   ```

2. **事件包含足够的信息**

   ```typescript
   export class UserCreatedEvent implements IEvent {
     constructor(
       public readonly userId: string,
       public readonly username: string,
       public readonly domain: string,
     ) {}
   }
   ```

3. **事件处理器应该是幂等的**
   ```typescript
   @EventsHandler(UserCreatedEvent)
   export class UserCreatedHandler {
     async handle(event: UserCreatedEvent) {
       // 幂等处理：检查是否已处理
       if (await this.isAlreadyProcessed(event.userId)) {
         return;
       }
       // 处理逻辑
     }
   }
   ```

### 8.2 ❌ 避免的做法

1. ❌ 事件命名使用现在时或将来时
2. ❌ 事件包含的信息不足
3. ❌ 事件处理器不是幂等的

## 9. 学习检查

完成本章学习后，请回答以下问题：

1. 事件驱动架构的核心思想是什么？
2. 领域事件的特点是什么？
3. 事件发布和处理的流程是什么？
4. 最终一致性是什么？
5. 事件驱动架构的优势是什么？

## 10. 下一步

- 学习 [领域驱动设计详解](./04-领域驱动设计详解.md)
- 查看 [架构原理文档 - 事件驱动架构](../../ARCHITECTURE.md#4-事件驱动架构eda)

---

**上一章**：[CQRS 模式详解](./02-CQRS模式详解.md)  
**下一章**：[领域驱动设计详解](./04-领域驱动设计详解.md)  
**返回**：[培训大纲](../README.md)
