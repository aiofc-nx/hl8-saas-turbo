# 核心概念

## 学习目标

- 理解 Clean Architecture 的核心概念
- 理解 CQRS 的核心概念
- 理解事件驱动架构的核心概念
- 理解领域驱动设计（DDD）的核心概念

## 1. Clean Architecture 核心概念

### 1.1 分层架构

Clean Architecture 采用分层架构，从外到内分为：

```
┌─────────────────────────────────────────┐
│ Infrastructure Layer (基础设施层)       │
│  - 数据库、Web框架、外部服务            │
└──────────────┬──────────────────────────┘
               │ 依赖
┌──────────────▼──────────────────────────┐
│ Application Layer (应用层)              │
│  - Use Case、命令/查询处理器             │
│  - Ports (端口接口)                     │
└──────────────┬──────────────────────────┘
               │ 依赖
┌──────────────▼──────────────────────────┐
│ Domain Layer (领域层)                    │
│  - 聚合根、值对象、领域事件              │
└─────────────────────────────────────────┘
```

**依赖方向**：外层 → 内层

### 1.2 依赖规则

**核心规则**：源代码依赖只能指向内层，外层依赖内层，内层不依赖外层。

**实现方式**：

- 应用层定义端口接口（Port）
- 基础设施层实现适配器（Adapter）
- 通过依赖注入连接

### 1.3 端口适配器模式

**端口（Port）**：在应用层定义的接口，表示"需要什么功能"

**适配器（Adapter）**：在基础设施层实现的类，表示"如何实现"

**示例**：

```typescript
// 端口（Port）- 应用层定义
export interface UserReadRepoPort {
  getUserById(id: string): Promise<UserProperties | null>;
}

// 适配器（Adapter）- 基础设施层实现
@Injectable()
export class UserReadRepository implements UserReadRepoPort {
  async getUserById(id: string) {
    // 具体实现
  }
}
```

## 2. CQRS 核心概念

### 2.1 命令（Command）

**定义**：表示用户意图的对象，用于修改系统状态。

**特点**：

- 不可变（immutable）
- 包含执行操作所需的所有信息
- 返回 void 或简单结果

**示例**：

```typescript
export class UserCreateCommand implements ICommand {
  constructor(
    readonly username: string,
    readonly password: string,
    readonly domain: string,
  ) {}
}
```

### 2.2 查询（Query）

**定义**：用于获取数据的对象，不改变系统状态。

**特点**：

- 不可变（immutable）
- 不修改系统状态
- 返回数据

**示例**：

```typescript
export class FindUserByIdQuery implements IQuery {
  constructor(readonly id: string) {}
}
```

### 2.3 读写分离

**写操作**：通过 Command Handler 处理，使用 Write Repository

**读操作**：通过 Query Handler 处理，使用 Read Repository

**优势**：

- 读写操作可以独立优化
- 可以为读写操作使用不同的数据模型
- 提升系统性能和可扩展性

## 3. 事件驱动架构核心概念

### 3.1 领域事件（Domain Event）

**定义**：领域内发生的、对业务有重要意义的事情。

**特点**：

- 不可变（immutable）
- 使用过去时命名
- 包含足够的信息

**示例**：

```typescript
export class UserCreatedEvent implements IEvent {
  constructor(
    public readonly userId: string,
    public readonly username: string,
    public readonly domain: string,
  ) {}
}
```

### 3.2 事件发布

**流程**：

1. 聚合根通过 `apply()` 方法应用事件
2. 调用 `commit()` 方法提交事件到事件总线
3. 事件总线分发事件给所有订阅者

**示例**：

```typescript
export class User extends AggregateRoot {
  async created() {
    this.apply(new UserCreatedEvent(this.id, this.username, this.domain));
  }
}

// 使用
await user.created();
this.publisher.mergeObjectContext(user);
user.commit();
```

### 3.3 事件处理

**流程**：

1. 事件处理器订阅特定类型的事件
2. 事件总线分发事件
3. 事件处理器异步处理事件

**示例**：

```typescript
@EventsHandler(UserCreatedEvent)
export class UserCreatedHandler implements IEventHandler {
  async handle(event: UserCreatedEvent) {
    // 异步处理事件
  }
}
```

### 3.4 最终一致性

**定义**：系统通过异步事件处理，最终达到一致的状态。

**优势**：

- 提升系统响应性
- 解耦模块
- 支持分布式系统

## 4. 领域驱动设计（DDD）核心概念

### 4.1 聚合根（Aggregate Root）

**定义**：聚合的入口点，负责维护聚合内部的业务规则和一致性。

**特点**：

- 有唯一标识（ID）
- 包含业务逻辑和业务规则
- 可以发布领域事件

**示例**：

```typescript
export class User extends AggregateRoot {
  readonly id: string;
  readonly username: string;

  async loginUser(password: string) {
    // 业务逻辑
  }

  async created() {
    this.apply(new UserCreatedEvent(...));
  }
}
```

### 4.2 值对象（Value Object）

**定义**：没有唯一标识的对象，通过值相等性判断。

**特点**：

- 无唯一标识
- 不可变（immutable）
- 通过值相等

**示例**：

```typescript
export class Password {
  private constructor(private readonly value: string) {}

  static fromHashed(hashed: string): Password {
    return new Password(hashed);
  }

  async compare(plainPassword: string): Promise<boolean> {
    // 密码比较逻辑
  }
}
```

### 4.3 有界上下文（Bounded Context）

**定义**：表示一个业务边界，在这个边界内，领域模型有明确的含义。

**示例**：

- IAM 有界上下文：身份和访问管理
- Order 有界上下文：订单管理

### 4.4 领域方法（Domain Method）

**定义**：定义在聚合根或值对象上的方法，用于封装业务逻辑和业务规则。

**类型**：

- **业务行为方法**：执行具体的业务操作
- **业务规则验证方法**：检查业务规则和约束
- **事件发布方法**：发布领域事件

## 5. Use Case 核心概念

### 5.1 Use Case 定义

**定义**：应用层的核心概念，代表一个完整的、独立的业务操作。

**特点**：

- **独立性**：每个 Use Case 是独立的业务操作
- **完整性**：Use Case 包含完成业务目标所需的所有步骤
- **编排性**：Use Case 协调领域对象完成业务目标
- **可测试性**：Use Case 可以独立测试

### 5.2 Use Case 实现方式

在 CQRS 模式下，Use Case 通过以下方式实现：

- **Command Handler** = **写操作 Use Case**
- **Query Handler** = **读操作 Use Case**
- **Application Service** = **复杂业务流程 Use Case**
- **Event Handler** = **事件处理 Use Case**

### 5.3 Use Case 示例

```typescript
// 写操作 Use Case
@CommandHandler(UserCreateCommand)
export class UserCreateHandler {
  async execute(command: UserCreateCommand) {
    // Use Case: 创建用户
  }
}

// 读操作 Use Case
@QueryHandler(FindUserByIdQuery)
export class FindUserByIdQueryHandler {
  async execute(query: FindUserByIdQuery) {
    // Use Case: 查询用户
  }
}
```

## 6. 学习检查

完成本章学习后，请回答以下问题：

1. Clean Architecture 的依赖规则是什么？
2. 端口和适配器的区别是什么？
3. 命令和查询的区别是什么？
4. 领域事件的特点是什么？
5. 聚合根和值对象的区别是什么？
6. Use Case 在应用层的作用是什么？

## 7. 下一步

- 学习 [项目结构](./03-项目结构.md)
- 查看 [架构原理文档](../../ARCHITECTURE.md)

---

**上一章**：[架构概述](./01-架构概述.md)  
**下一章**：[项目结构](./03-项目结构.md)  
**返回**：[培训大纲](../README.md)
