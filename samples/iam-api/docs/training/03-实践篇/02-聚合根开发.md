# 聚合根开发

## 学习目标

- 掌握聚合根的设计原则
- 理解领域方法的编写
- 掌握工厂方法的使用
- 理解领域事件的发布

## 1. 聚合根设计原则

### 1.1 什么是聚合根？

**定义**：聚合的入口点，负责维护聚合内部的业务规则和一致性。

**特点**：

- 有唯一标识（ID）
- 包含业务逻辑和业务规则
- 可以发布领域事件
- 保护业务不变量

### 1.2 设计原则

1. **业务逻辑集中**：业务逻辑应该在聚合根中
2. **保护不变量**：聚合根负责维护业务不变量
3. **最小化聚合**：聚合应该尽可能小
4. **通过标识引用**：聚合之间通过标识引用，不直接引用对象

## 2. 聚合根结构

### 2.1 基本结构

```typescript
export class User extends AggregateRoot implements IUser {
  // 1. 属性定义（只读）
  readonly id: string;
  readonly username: string;
  readonly password: Password;  // 值对象
  readonly domain: string;
  readonly status: Status;

  // 2. 构造函数
  constructor(properties: UserProperties) {
    super();
    Object.assign(this, properties);
    // 值对象转换
    if ('password' in properties && properties.password) {
      this.password = Password.fromHashed(properties.password);
    }
  }

  // 3. 领域方法
  async loginUser(password: string) {
    // 业务逻辑
  }

  // 4. 事件发布方法
  async created() {
    this.apply(new UserCreatedEvent(...));
  }
}
```

### 2.2 属性设计

**原则**：

- 使用 `readonly` 确保不可变性
- 值对象使用专门的类（如 `Password`）
- 枚举类型使用枚举（如 `Status`）

**示例**：

```typescript
export class User extends AggregateRoot {
  readonly id: string; // 唯一标识
  readonly username: string; // 业务属性
  readonly password: Password; // 值对象
  readonly status: Status; // 枚举类型
  readonly domain: string; // 业务属性
}
```

## 3. 领域方法（Domain Methods）

### 3.1 什么是领域方法？

**定义**：定义在聚合根或值对象上的方法，用于封装业务逻辑和业务规则。

**类型**：

- **业务行为方法**：执行具体的业务操作
- **业务规则验证方法**：检查业务规则和约束
- **事件发布方法**：发布领域事件

### 3.2 业务行为方法

**示例**：用户登录

```typescript
export class User extends AggregateRoot {
  /**
   * 用户登录
   *
   * @description 执行用户登录逻辑，包括状态检查和密码验证
   */
  async loginUser(
    password: string,
  ): Promise<{ success: boolean; message: string }> {
    // 业务规则 1: 检查用户状态
    if (this.status !== Status.ENABLED) {
      return {
        success: false,
        message: `User is ${this.status.toLowerCase()}.`,
      };
    }

    // 业务规则 2: 验证密码
    const isPasswordValid = await this.verifyPassword(password);
    if (!isPasswordValid) {
      return { success: false, message: 'Invalid credentials.' };
    }

    // 业务逻辑：登录成功
    return { success: true, message: 'Login successful' };
  }
}
```

### 3.3 业务规则验证方法

**示例**：验证密码

```typescript
export class User extends AggregateRoot {
  /**
   * 验证密码
   *
   * @description 验证提供的密码是否与用户密码匹配
   */
  async verifyPassword(password: string): Promise<boolean> {
    return this.password.compare(password);
  }

  /**
   * 检查是否可以登录
   *
   * @description 检查用户状态是否允许登录
   */
  async canLogin(): Promise<boolean> {
    return this.status === Status.ENABLED;
  }
}
```

### 3.4 事件发布方法

**示例**：发布用户创建事件

```typescript
export class User extends AggregateRoot {
  /**
   * 发布用户创建事件
   *
   * @description 当用户被创建时，发布 UserCreatedEvent 事件
   */
  async created() {
    this.apply(new UserCreatedEvent(this.id, this.username, this.domain));
  }

  /**
   * 发布用户删除事件
   *
   * @description 当用户被删除时，发布 UserDeletedEvent 事件
   */
  async deleted() {
    this.apply(new UserDeletedEvent(this.id, this.username, this.domain));
  }
}
```

## 4. 工厂方法（Factory Methods）

### 4.1 什么是工厂方法？

**定义**：用于创建聚合根实例的静态方法。

**优势**：

- 封装创建逻辑
- 支持不同的创建场景
- 确保对象正确初始化

### 4.2 常见工厂方法

**示例**：

```typescript
export class User extends AggregateRoot {
  /**
   * 从创建属性创建用户实例
   */
  static fromCreate(properties: UserCreateProperties): User {
    return Object.assign(new User(), properties);
  }

  /**
   * 从更新属性创建用户实例
   */
  static fromUpdate(properties: UserUpdateProperties): User {
    return Object.assign(new User(), properties);
  }

  /**
   * 从完整属性创建用户实例
   */
  static fromProp(properties: UserProperties): User {
    return Object.assign(new User(), properties);
  }
}
```

### 4.3 使用工厂方法

**在 Command Handler 中使用**：

```typescript
@CommandHandler(UserCreateCommand)
export class UserCreateHandler {
  async execute(command: UserCreateCommand) {
    const userCreateProperties: UserCreateProperties = {
      id: UlidGenerator.generate(),
      username: command.username,
      // ...
    };

    // 使用工厂方法创建
    const user = User.fromCreate(userCreateProperties);
    // 或者直接使用构造函数
    // const user = new User(userCreateProperties);

    await this.repository.save(user);
  }
}
```

## 5. 值对象的使用

### 5.1 值对象定义

**示例**：Password 值对象

```typescript
export class Password {
  private constructor(private readonly value: string) {}

  // 工厂方法：从明文密码创建
  static async hash(password: string): Promise<Password> {
    const salt = await bcrypt.genSalt();
    const hashedPassword = await bcrypt.hash(password, salt);
    return new Password(hashedPassword);
  }

  // 工厂方法：从已哈希的密码创建
  static fromHashed(hashed: string): Password {
    return new Password(hashed);
  }

  // 比较密码
  async compare(plainPassword: string): Promise<boolean> {
    return await bcrypt.compare(plainPassword, this.value);
  }

  // 获取密码哈希值
  getValue(): string {
    return this.value;
  }
}
```

### 5.2 在聚合根中使用值对象

```typescript
export class User extends AggregateRoot {
  readonly password: Password; // 值对象

  constructor(properties: UserProperties) {
    super();
    Object.assign(this, properties);
    // 值对象转换
    if ('password' in properties && properties.password) {
      this.password = Password.fromHashed(properties.password);
    }
  }

  async verifyPassword(password: string): Promise<boolean> {
    return this.password.compare(password); // 使用值对象的方法
  }
}
```

## 6. 领域事件发布

### 6.1 事件定义

```typescript
export class UserCreatedEvent implements IEvent {
  constructor(
    public readonly userId: string,
    public readonly username: string,
    public readonly domain: string,
  ) {}
}
```

### 6.2 事件发布流程

```typescript
// 1. 聚合根发布事件
export class User extends AggregateRoot {
  async created() {
    this.apply(new UserCreatedEvent(this.id, this.username, this.domain));
  }
}

// 2. 在 Command Handler 中提交事件
@CommandHandler(UserCreateCommand)
export class UserCreateHandler {
  async execute(command: UserCreateCommand) {
    const user = new User(...);
    await this.repository.save(user);

    // 发布事件
    await user.created();

    // 合并上下文并提交事件
    this.publisher.mergeObjectContext(user);
    user.commit();
  }
}
```

## 7. 开发检查清单

### 7.1 聚合根开发清单

- [ ] 分析业务需求，识别业务概念
- [ ] 设计聚合根属性和业务方法
- [ ] 识别值对象（Password、Money 等）
- [ ] 定义领域事件
- [ ] 实现业务逻辑和业务规则
- [ ] 编写工厂方法（fromCreate、fromUpdate 等）
- [ ] 不依赖任何数据库或 ORM 代码

### 7.2 领域方法检查清单

- [ ] 领域方法封装业务逻辑
- [ ] 领域方法维护业务不变量
- [ ] 领域方法使用业务术语命名
- [ ] 事件发布方法正确使用 `apply()`

## 8. 常见错误

### 8.1 ❌ 错误：在聚合根中使用数据库代码

```typescript
// ❌ 错误
export class User extends AggregateRoot {
  async save() {
    await this.repository.save(this); // 不应该在聚合根中直接调用仓储
  }
}
```

### 8.2 ✅ 正确：在 Command Handler 中调用仓储

```typescript
// ✅ 正确
@CommandHandler(UserCreateCommand)
export class UserCreateHandler {
  async execute(command: UserCreateCommand) {
    const user = new User(...);
    await this.repository.save(user);  // 在 Handler 中调用仓储
  }
}
```

## 9. 学习检查

完成本章学习后，请回答以下问题：

1. 聚合根的设计原则是什么？
2. 领域方法的类型有哪些？
3. 工厂方法的作用是什么？
4. 如何发布领域事件？

## 10. 下一步

- 学习 [Use Case 开发](./03-Use-Case开发.md)
- 查看 [开发流程指南](./01-开发流程指南.md)

---

**上一章**：[开发流程指南](./01-开发流程指南.md)  
**下一章**：[Use Case 开发](./03-Use-Case开发.md)  
**返回**：[培训大纲](../README.md)
