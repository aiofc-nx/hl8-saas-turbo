# 聚合根与数据库实体映射

## 学习目标

- 理解聚合根到数据库实体的映射机制
- 掌握写入映射的实现
- 掌握读取映射的实现
- 理解值对象的映射处理
- 掌握同步维护策略

## 1. 映射概述

### 1.1 为什么需要映射？

在 Clean Architecture 中，领域模型和数据库实体是**分离的**：

- **领域模型**：业务概念的表达，不依赖技术
- **数据库实体**：技术实现，用于持久化数据

需要通过映射机制进行转换。

### 1.2 映射位置

映射在**仓储实现（Repository Implementation）**中进行，位于基础设施层：

```
src/infra/bounded-contexts/
  └── iam/
      └── authentication/
          └── repository/
              ├── user.write.pg.repository.ts  # 写入映射
              └── user.read.pg.repository.ts   # 读取映射
```

## 2. 写入映射（Domain → Entity）

### 2.1 基本映射

**实现方式**：对象展开 + 值对象提取

```typescript
async save(user: User): Promise<void> {
  // 1. 将聚合根转换为普通对象
  const userData = {
    ...user,                    // 展开聚合根的所有属性
    password: user.password.getValue(),  // 提取值对象的值
  };

  // 2. 使用 MikroORM 创建实体
  const newUser = this.em.create('SysUser', userData);

  // 3. 持久化到数据库
  await this.em.persistAndFlush(newUser);
}
```

### 2.2 值对象映射

**关键点**：值对象需要显式转换

```typescript
// 领域模型
export class User extends AggregateRoot {
  readonly password: Password;  // 值对象
}

// 数据库实体
@Entity({ tableName: 'sys_user' })
export class SysUser {
  @Property({ nullable: true })
  password?: string;  // 基础类型
}

// 映射逻辑
async save(user: User): Promise<void> {
  const userData = {
    ...user,
    password: user.password.getValue(),  // Password 值对象 → string
  };
}
```

## 3. 读取映射（Entity → Domain）

### 3.1 基本映射

**实现方式**：类型断言

```typescript
async findUserById(id: string): Promise<UserProperties | null> {
  // 1. 从数据库查询实体
  const user = await this.em.findOne('SysUser', { id } as FilterQuery<any>);

  // 2. 类型断言转换为 Properties
  return user as UserProperties | null;
}
```

### 3.2 值对象恢复

**位置**：在聚合根构造函数中

```typescript
export class User extends AggregateRoot {
  constructor(properties: UserProperties) {
    super();
    Object.assign(this, properties);
    // 值对象恢复
    if ('password' in properties && properties.password) {
      this.password = Password.fromHashed(properties.password); // string → Password
    }
  }
}
```

## 4. 更新映射

### 4.1 选择性字段更新

**实现方式**：只更新允许修改的字段

```typescript
async update(user: User): Promise<void> {
  await this.em.nativeUpdate(
    'SysUser',
    { id: user.id },  // 查询条件
    {
      // 只更新允许修改的字段
      nickName: user.nickName,
      status: user.status,
      avatar: user.avatar,
      email: user.email,
      phoneNumber: user.phoneNumber,
      updatedAt: new Date(),
      updatedBy: user.createdBy,
      // 不更新 id, username, password, domain 等不可变字段
    },
  );
}
```

## 5. 映射模式

### 5.1 当前实现模式：隐式映射

**特点**：

- 不使用专门的 Mapper 类
- 依赖对象结构兼容性
- 在仓储方法中直接处理映射逻辑
- 使用类型断言进行类型转换

**优点**：

- 实现简单，代码量少
- 不需要维护额外的映射类
- 性能好（无额外转换开销）

**缺点**：

- 映射逻辑分散在多个仓储方法中
- 字段不匹配时容易出错（运行时才能发现）
- 值对象需要手动提取

### 5.2 映射流程

#### 写入流程

```
CommandHandler
    ↓
创建聚合根 (User.fromCreate())
    ↓
仓储.save(user: User)
    ↓
提取值对象 (user.password.getValue())
    ↓
对象展开 ({ ...user, password: ... })
    ↓
em.create('SysUser', userData)
    ↓
em.persistAndFlush()
    ↓
数据库
```

#### 读取流程

```
QueryHandler
    ↓
仓储.findUserById(id)
    ↓
em.findOne('SysUser', { id })
    ↓
类型断言 (as UserProperties)
    ↓
返回 UserProperties
    ↓
QueryHandler 返回给 Controller
```

## 6. 同步维护

### 6.1 变更影响

当聚合根发生改变时，需要手动修改：

1. ✅ 数据库实体类：添加/修改字段
2. ✅ 数据库迁移脚本：修改表结构
3. ✅ 仓储映射逻辑：处理新字段（如果需要）
4. ✅ 读取模型（UserProperties）：添加类型定义

### 6.2 检查清单

**聚合根变更检查清单**：

- [ ] 修改聚合根类
- [ ] 更新 UserProperties 类型
- [ ] 更新 UserCreateProperties 类型
- [ ] 更新 UserUpdateProperties 类型
- [ ] 修改数据库实体类（SysUser）
- [ ] 创建数据库迁移脚本
- [ ] 更新写入仓储映射逻辑
- [ ] 更新读取仓储映射逻辑（如果需要）

### 6.3 减少维护成本的方法

1. **保持字段名称一致**：聚合根和数据库实体使用相同的字段名称
2. **使用类型定义共享**：定义共享的 Properties 类型
3. **创建变更检查清单**：每次变更时使用检查清单

## 7. 最佳实践

### 7.1 ✅ 推荐做法

1. **保持字段名称一致**

   ```typescript
   // 聚合根
   readonly lastLoginAt: Date | null;

   // 数据库实体
   @Property({ nullable: true })
   lastLoginAt?: Date | null;  // 名称一致
   ```

2. **值对象显式转换**

   ```typescript
   // 写入
   password: user.password.getValue();

   // 读取（在构造函数中）
   this.password = Password.fromHashed(properties.password);
   ```

3. **更新字段选择**
   ```typescript
   // 只更新允许修改的字段
   await this.em.nativeUpdate(
     'SysUser',
     { id: user.id },
     {
       nickName: user.nickName, // 允许修改
       // 不包含不可变字段
     },
   );
   ```

### 7.2 ❌ 避免的做法

1. ❌ 字段名称不一致
2. ❌ 忽略值对象转换
3. ❌ 更新时包含不可变字段

## 8. 学习检查

完成本章学习后，请回答以下问题：

1. 为什么需要映射？
2. 写入映射如何实现？
3. 读取映射如何实现？
4. 值对象如何映射？
5. 如何减少维护成本？

## 9. 下一步

- 学习 [用户管理模块案例](../04-案例篇/01-用户管理模块案例.md)
- 查看 [聚合根与数据库实体映射文档](../../AGGREGATE-ENTITY-MAPPING.md)
- 查看 [聚合根与数据库实体同步维护文档](../../DOMAIN-ENTITY-SYNC.md)

---

**上一章**：[端口适配器实现](./04-端口适配器实现.md)  
**下一章**：[用户管理模块案例](../04-案例篇/01-用户管理模块案例.md)  
**返回**：[培训大纲](../README.md)
