# 端口适配器实现

## 学习目标

- 理解端口适配器模式
- 掌握端口接口的定义
- 掌握适配器的实现
- 理解依赖注入配置
- 掌握映射逻辑的编写

## 1. 端口适配器模式概述

### 1.1 核心概念

**端口（Port）**：在应用层定义的接口，表示"需要什么功能"。

**适配器（Adapter）**：在基础设施层实现的类，表示"如何实现"。

### 1.2 模式优势

- ✅ **解耦**：应用层不依赖具体实现
- ✅ **可替换**：可以轻松替换实现（如从 PostgreSQL 切换到 MongoDB）
- ✅ **可测试**：可以使用 Mock 实现进行测试

## 2. 端口接口定义

### 2.1 写入仓储端口

**位置**：`src/lib/bounded-contexts/{context}/{module}/ports/{module}.write.repo-port.ts`

**特点**：

- 定义在应用层
- 使用领域模型（不是数据库实体）
- 表示需求，不关心实现

**示例**：

```typescript
// lib/bounded-contexts/iam/authentication/ports/user.write.repo-port.ts
export interface UserWriteRepoPort {
  /**
   * 保存用户
   *
   * @param user - 用户聚合根
   */
  save(user: User): Promise<void>;

  /**
   * 更新用户
   *
   * @param user - 用户聚合根
   */
  update(user: User): Promise<void>;

  /**
   * 根据 ID 删除用户
   *
   * @param id - 用户 ID
   */
  deleteById(id: string): Promise<void>;

  /**
   * 根据用户 ID 删除用户角色关联
   *
   * @param userId - 用户 ID
   */
  deleteUserRoleByUserId(userId: string): Promise<void>;
}
```

### 2.2 读取仓储端口

**位置**：`src/lib/bounded-contexts/{context}/{module}/ports/{module}.read.repo-port.ts`

**特点**：

- 定义在应用层
- 返回读模型（Properties），不是聚合根
- 优化查询性能

**示例**：

```typescript
// lib/bounded-contexts/iam/authentication/ports/user.read.repo-port.ts
export interface UserReadRepoPort {
  /**
   * 根据 ID 查找用户
   *
   * @param id - 用户 ID
   * @returns 用户属性对象，如果不存在则返回 null
   */
  findUserById(id: string): Promise<UserProperties | null>;

  /**
   * 根据用户名查找用户
   *
   * @param username - 用户名
   * @returns 用户属性对象，如果不存在则返回 null
   */
  getUserByUsername(username: string): Promise<Readonly<UserProperties> | null>;

  /**
   * 分页查询用户
   *
   * @param query - 分页查询参数
   * @returns 分页结果
   */
  pageUsers(query: PageUsersQuery): Promise<PaginationResult<UserProperties>>;

  /**
   * 根据用户 ID 查找角色代码集合
   *
   * @param userId - 用户 ID
   * @returns 角色代码集合
   */
  findRolesByUserId(userId: string): Promise<Set<string>>;
}
```

## 3. 适配器实现

### 3.1 写入仓储适配器

**位置**：`src/infra/bounded-contexts/{context}/{module}/repository/{module}.write.pg.repository.ts`

**特点**：

- 实现端口接口
- 处理技术细节（MikroORM）
- 处理聚合根到数据库实体的映射

**示例**：

```typescript
// infra/bounded-contexts/iam/authentication/repository/user.write.pg.repository.ts
@Injectable()
export class UserWriteRepository implements UserWriteRepoPort {
  constructor(private readonly em: EntityManager) {}

  async save(user: User): Promise<void> {
    // 聚合根 → 数据库实体映射
    const userData = {
      ...user,
      password: user.password.getValue(), // 值对象转换
    };
    const newUser = this.em.create('SysUser', userData);
    await this.em.persistAndFlush(newUser);
  }

  async update(user: User): Promise<void> {
    await this.em.nativeUpdate(
      'SysUser',
      { id: user.id },
      {
        nickName: user.nickName,
        status: user.status,
        avatar: user.avatar,
        email: user.email,
        phoneNumber: user.phoneNumber,
        updatedAt: new Date(),
        updatedBy: user.createdBy,
      },
    );
  }

  async deleteById(id: string): Promise<void> {
    await this.em.nativeDelete('SysUser', { id });
  }
}
```

### 3.2 读取仓储适配器

**位置**：`src/infra/bounded-contexts/{context}/{module}/repository/{module}.read.pg.repository.ts`

**特点**：

- 实现端口接口
- 返回读模型（Properties）
- 优化查询性能

**示例**：

```typescript
// infra/bounded-contexts/iam/authentication/repository/user.read.pg.repository.ts
@Injectable()
export class UserReadRepository implements UserReadRepoPort {
  constructor(private readonly em: EntityManager) {}

  async findUserById(id: string): Promise<UserProperties | null> {
    const user = await this.em.findOne('SysUser', { id } as FilterQuery<any>);
    return user as UserProperties | null; // 类型断言
  }

  async getUserByUsername(
    username: string,
  ): Promise<Readonly<UserProperties> | null> {
    const user = await this.em.findOne('SysUser', {
      username,
    } as FilterQuery<any>);
    return user as Readonly<UserProperties> | null;
  }

  async pageUsers(
    query: PageUsersQuery,
  ): Promise<PaginationResult<UserProperties>> {
    const where: FilterQuery<any> = {};
    if (query.username) {
      where.username = { $like: `%${query.username}%` };
    }
    if (query.status) {
      where.status = query.status;
    }

    const [users, total] = await this.em.findAndCount('SysUser', where, {
      limit: query.size,
      offset: (query.current - 1) * query.size,
    });

    return new PaginationResult<UserProperties>(
      query.current,
      query.size,
      total,
      users as unknown as UserProperties[],
    );
  }
}
```

## 4. 依赖注入配置

### 4.1 端口令牌定义

**位置**：`src/lib/bounded-contexts/{context}/{module}/constants.ts`

**示例**：

```typescript
// lib/bounded-contexts/iam/authentication/constants.ts
export const UserReadRepoPortToken = Symbol('UserReadRepoPort');
export const UserWriteRepoPortToken = Symbol('UserWriteRepoPort');
```

### 4.2 在应用层注入端口

**示例**：

```typescript
@CommandHandler(UserCreateCommand)
export class UserCreateHandler {
  @Inject(UserWriteRepoPortToken)
  private readonly userWriteRepository: UserWriteRepoPort; // 注入端口接口

  @Inject(UserReadRepoPortToken)
  private readonly userReadRepoPort: UserReadRepoPort; // 注入端口接口
}
```

### 4.3 在基础设施层注册实现

**位置**：`src/infra/bounded-contexts/{context}/{module}/{module}.module.ts`

**示例**：

```typescript
// infra/bounded-contexts/iam/authentication/authentication.module.ts
@Module({
  providers: [
    // 注册端口接口的实现
    {
      provide: UserReadRepoPortToken,
      useClass: UserReadRepository, // 绑定适配器实现
    },
    {
      provide: UserWriteRepoPortToken,
      useClass: UserWriteRepository, // 绑定适配器实现
    },
    // ... 其他提供者
  ],
})
export class AuthenticationModule {}
```

## 5. 映射逻辑

### 5.1 写入映射（Domain → Entity）

**场景**：将聚合根保存到数据库

**实现方式**：对象展开 + 值对象提取

```typescript
async save(user: User): Promise<void> {
  // 1. 将聚合根转换为普通对象
  const userData = {
    ...user,                    // 展开聚合根的所有属性
    password: user.password.getValue(),  // 提取值对象的值
  };

  // 2. 使用 MikroORM 创建实体
  const newUser = this.em.create('SysUser', userData);

  // 3. 持久化到数据库
  await this.em.persistAndFlush(newUser);
}
```

### 5.2 读取映射（Entity → Domain）

**场景**：从数据库读取数据并转换为领域模型

**实现方式**：类型断言

```typescript
async findUserById(id: string): Promise<UserProperties | null> {
  // 1. 从数据库查询实体
  const user = await this.em.findOne('SysUser', { id } as FilterQuery<any>);

  // 2. 类型断言转换为 Properties
  return user as UserProperties | null;
}
```

### 5.3 值对象映射

**写入**：值对象 → 基础类型

```typescript
async save(user: User): Promise<void> {
  const userData = {
    ...user,
    password: user.password.getValue(),  // Password 值对象 → string
  };
}
```

**读取**：基础类型 → 值对象（在聚合根构造函数中）

```typescript
export class User extends AggregateRoot {
  constructor(properties: UserProperties) {
    super();
    Object.assign(this, properties);
    // 值对象转换
    if ('password' in properties && properties.password) {
      this.password = Password.fromHashed(properties.password); // string → Password
    }
  }
}
```

## 6. 替换实现

### 6.1 替换数据库（实际案例）

**优势**：由于使用了端口适配器模式，可以轻松替换数据库实现。

**实际案例**：未来计划从 PostgreSQL 迁移到 MongoDB，ORM 保持不变（MikroORM）

**迁移步骤**：

1. **修改数据库配置**（只需修改配置文件）

   ```typescript
   // mikro-orm.config.ts
   export default {
     // 从 PostgreSQL
     // type: 'postgresql',

     // 改为 MongoDB
     type: 'mongo',
     clientUrl: 'mongodb://localhost:27017',
     dbName: 'iam_db',
   };
   ```

2. **调整实体装饰器**（最小修改）

   ```typescript
   // 从
   @Entity({ tableName: 'sys_user' })
   // 改为
   @Entity({ collection: 'sys_user' })  // 仅名称变化
   ```

3. **仓储实现**（大部分代码无需修改）
   ```typescript
   // MikroORM API 统一，大部分代码保持不变
   @Injectable()
   export class UserWriteRepository implements UserWriteRepoPort {
     async save(user: User): Promise<void> {
       // MikroORM API 统一，代码无需修改
       const userData = { ...user, password: user.password.getValue() };
       const newUser = this.em.create('SysUser', userData);
       await this.em.persistAndFlush(newUser);
     }
   }
   ```

**无需修改的代码**：

- ✅ 应用层代码（Command Handler、Query Handler）
- ✅ 领域层代码（聚合根、值对象）
- ✅ 端口接口定义
- ✅ 大部分仓储实现代码

**需要修改的代码**：

- ⚠️ 数据库配置（mikro-orm.config.ts）
- ⚠️ 实体装饰器（tableName → collection）
- ⚠️ 某些复杂查询（如果需要）

**详细迁移指南**：请参阅 [数据库迁移指南](./06-数据库迁移指南.md)

## 7. 开发检查清单

### 7.1 端口接口开发清单

- [ ] 定义在应用层（lib/.../ports/）
- [ ] 使用领域模型（不是数据库实体）
- [ ] 接口方法有完整的 TSDoc 注释
- [ ] 写入端口使用聚合根
- [ ] 读取端口返回 Properties

### 7.2 适配器实现检查清单

- [ ] 实现端口接口
- [ ] 定义在基础设施层（infra/.../repository/）
- [ ] 处理聚合根到数据库实体的映射
- [ ] 处理值对象的转换
- [ ] 使用 ORM 框架（MikroORM）

### 7.3 依赖注入检查清单

- [ ] 定义端口令牌（Symbol）
- [ ] 在应用层注入端口接口
- [ ] 在基础设施层注册适配器实现
- [ ] 模块正确配置

## 8. 常见错误

### 8.1 ❌ 错误：在端口接口中使用数据库实体

```typescript
// ❌ 错误
export interface UserWriteRepoPort {
  save(entity: SysUser): Promise<void>; // 不应该使用数据库实体
}
```

### 8.2 ✅ 正确：在端口接口中使用领域模型

```typescript
// ✅ 正确
export interface UserWriteRepoPort {
  save(user: User): Promise<void>; // 使用领域模型
}
```

## 9. 学习检查

完成本章学习后，请回答以下问题：

1. 端口和适配器的区别是什么？
2. 端口接口应该定义在哪里？
3. 适配器应该实现什么？
4. 如何配置依赖注入？
5. 如何实现聚合根到数据库实体的映射？

## 10. 下一步

- 学习 [聚合根与数据库实体映射](./05-聚合根与数据库实体映射.md)
- 查看 [聚合根与数据库实体映射文档](../../AGGREGATE-ENTITY-MAPPING.md)

---

**上一章**：[Use Case 开发](./03-Use-Case开发.md)  
**下一章**：[聚合根与数据库实体映射](./05-聚合根与数据库实体映射.md)  
**返回**：[培训大纲](../README.md)
